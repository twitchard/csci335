<!DOCTYPE html>
<html>
  <head>
    <title>Marmorstein's Revenge: The Age of ChemTutor</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-slide-content {
          background: black;
          color: white;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle, titlepage
# Marmorstein's <span style="color:red">Revenge</span>
## The Age of ChemTutor

<marquee>Adventure awaits</marquee>
<p>Slides: https://twitchard.github.io/csci335</p>
<p>Code: https://github.com/twitchard/csci335</p>
---
class: center, middle
# Anatomy of Large Web Applications

<p>Slides: https://twitchard.github.io/csci335</p>
<p>Code: https://github.com/twitchard/csci335</p>
---
## Who am I?

- Graduated in 2014.
- Dropped out of Economics PhD
- Feb 2015 - API Team @ Livestream
- Oct 2017 - Vimeo Live @ Vimeo
- Sep 2018 - Developer Experience @ Vimeo
- Lead Engineer / Hiring Manager

---

class: center, middle
# What will I be talking about?

---

class: center, middle
<h1 style="color:red">The Unthinkable</span>

---

class: center, middle
![](taytay.png)

---
class: middle
## Handling lots of traffic?
  1. Use caches!
  2. More servers!

---
class: middle
## Handling lots of developers?
  - APIs
  - Message Busses / Event
  - "Microservices"

---
class: middle
## Handling the <span style="color:red">haters</span> who want to bring you down?
  - XSS attacks
  - CSRF attacks (and CORS)
  - Web authentication

---
class: center, middle
# Hiring / Interviewing
---

class: center, middle
# How do you handle a lot of traffic?
## PART 1 - Caches
---

class: center, middle
## What is a cache?

???

What does a cache give you, and what do you pay for it?

---

class: center, middle
## What types of caches are there?

AKA: Where can caches live?

---

## Where can caches live

* inside the client application
* inside the browser (etags, cache-control header)
* in front of the application (CDN, HTTP reverse proxy)
* inside of the server application process (please don't do this)
* in a key-value store "in front of" the SQL database (redis, memcached)
* inside the SQL database (query cache)

---
## Cache inside the client application
---

## Cache inside the client application

```html
<button onClick="updateData()">get the latest chemistries</button>
<div id="dataGoesHere"></div>
```

### Doesn't use a cache
```javascript
async function updateData () {
    const ids = await getIdsOfLatestChemistriesFromServer()
    const data = []
    for (id of ids) {
        data.push(
            // This calls getChemistryFromServer even if we've
            // already fetched the chemistry the previous time the
            // user clicked
            await getChemistryFromServer(id)
        )
    }
    document.getElementById('dataGoesHere').innerHTML = renderChemistries(data)
}
```

---

### Makes a request only once every 2 minutes
```javascript
let cache = {}
async function getChemistryFromCachedServer (id) {
    if (cache[id] &&
        cache[id].time > Date.now() - TWO_MINUTES
    ) {
        return cache[id].value
    } 
    const value = await getChemistryFromServer(id)
    cache[id] = {value, time: Date.now()}
}
```
---
## Some Javascript front-end frameworks do this by default

"Ember.js" (not that popular, but influential)

---

class: center, middle
## The Browser Cache

* The server can ask the browser to cache a response by providing a "cache-control header".

* Skim (but probably don't read) [the RFC about caching.](https://tools.ietf.org/html/rfc7234)

## Cache-control examples:
* Example:

```sh
$ curl wikipedia.org -I -L -s | grep cache-control
cache-control: s-maxage=86400, must-revalidate, max-age=3600
```

`max-age=3600` means that browsers can cache the page for an hour.

???
If you visited the Wikipedia landing page, and then somebody made an edit, you would not see it until an hour later.

Unless you cleared your cache, or opened an incognito window.

---
## More cache-control examples

**The article about caching is not cached at all (by browsers)**
```
$ curl 'https://en.wikipedia.org/wiki/Cache_(computing)' -I -s | grep cache-control
cache-control: private, s-maxage=0, max-age=0, must-revalidate
```

**But the "Wikimedia Foundation" image that is on every wikipedia article is cached for AGES.**
```
curl 'https://en.wikipedia.org/static/images/wikimedia-button-2x.png' -s -I | grep cache-control
cache-control: max-age=31536000
```

???

Does everybody know what HTTP headers are?
Does everybody know about curl?
---

## I built <a href="cacheme.js">my own example</a>

---
## ETags

Etags are a way for the server to avoid retransmitting large responses. An etag is like a "version number" for the response.

1. The server provides an etag header.

2. The client remembers the response and the etag.

3. When the client asks again, they specify the etag in the "If-None-Match" header.

4. If the old response is up-to-date, the server can check that the etag is current, and then say
"304 not modified", instead of retransmitting a big file.

- This is important for images and other media.
- Etags are usually a hash/checksum of the file contents.

## ETag Example

```javascript
const server = require('http').createServer((req,res) => {
    if (req.headers['if-none-match'] === 'abc') {
        res.writeHead(304, {
            etag: 'abc'
        })
        res.end()
        return
    }
    res.writeHead(200, {
        etag: 'abc'
    })
    res.write('richard was here')
    res.end() 
})
server.listen(3000)
```
???
node etags.js

curl localhost:3000 -H "if-none-match:abc"
Ok, so browser caches only help reduce duplicate traffic from each client. But if I have a million different Taylor Swift fans, how do I handle that?
---

## Public caches

- Browser caches are 'private' caches.
- Reduce duplicate traffic from a single client.
- But Taylor Swift's 83 million followers aren't all using a single browser.

---

## Public caches

Public caches are shared across many users. One example: Varnish.

---
class
## What does Varnish do

- It is very very very fast at sending and receiving HTTP requests. 20,000+ requests per second, possibly.
- Goes "in front" of your application server.
- The application server only has to generate the response once -- for *any* client. Varnish will take care of all repeat requests. (Until it expires) 

???
sudo varnishd -b localhost:3000 -F
curl localhost:80

Make sure to clear cookies

$ httperf --server localhost --port 3000 --num-calls 10 --num-conns 5 --uri /chemistry/:organic --rate 10

$ httperf --server localhost --port 80 --num-calls 100000 --num-conns 5 --uri /chemistry/:organic --rate 10
---

## Cache terminology
* **Cache hit** - the requested object was in the cache
* **Cache miss** - the requested object was not in the cache
* **Cache bust** - to remove an object from the cache (before it expires)
* **Warm the cache** - to put an object in the cache, so it can be ready before a real client requests it

---

## Cache busting

- **Advantage:** You can eliminate stale data but still get to use your cache.
- **Disadvantage:** Complexity. "Two hard problems in computer science"

---

## CDNs

- "Content Delivery Network"
- You pay them, and they will put public caches on their servers all around the world.
- Your servers are the "origin". Their servers are the "edges".
- Less control than running your own caches.
- Examples: Cloudflare, Akamai, Fastly
- Cloud providers: "Amazon Cloudfront", "Google Cloud CDN", "Azure CDN"

---
# Limitations

- Private data! Can't put data for logged in users in a public cache.
- Can only cache reads. Won't help you with writes.

---
class: center, middle
# Key-Value Caches
- Behind your servers
- Can protect the database
- Can store the results of computationally intensive queries

- Very very fast at storing and retrieving data
- Typically store in memory
- No indices.
- Examples: Redis, Memcached
???
Not the same as read replicas. Read replicas copy ALL data, not just the results of queries.
---

## "Eviction Strategies"

When you run out of memory, you make room for new entries via "eviction"
- LRU (least-recently used)
- LFU (least-frequently used)
- Random
- Custom

---
class: center, middle
## Example?
???
redis-server
vim fibbonacci.js
time curl localhost:3000/fib/42
time curl localhost:3000/cached_fib/42
time curl localhost:3000/cached_fib/42

---

## Query Caches

Your database server itself has various caches inside.

- MySQL used to have something called the "query cache" but this was removed in the latest version.
- PostgreSQL has various caching mechanisms that you can tune.

---
class: center, middle
# But what about writes????

???
So there are two types of requests -- reads, and writes.

To show somebody a webpage, that's mostly only reads.

But if people are submitting data to you, editing their profile, changing their settings -- that's writes. Caches can't help you at all there.

There's nothing to do but spin up more servers.

---

## Load Balancers



Things used to be, you have a datacenter, somebody physically buys a computer, mounts it on a rack, plugs it in to a router...

Then along came hardware virtualization

"Pets Vs. Cattle"
That's how it was


    </textarea>
    <script src="remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
